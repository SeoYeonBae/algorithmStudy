package baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main_17406_배열돌리기4 {

	static int rec, K;
	static int[][] map;
	static Stack<Integer> stack = new Stack<>();
	static List<int[]> perms;
	static int[] numbers;
	static boolean[] isSelected;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		
		st = new StringTokenizer(br.readLine(), " ");
		int N = Integer.parseInt(st.nextToken()) + 1;
		int M = Integer.parseInt(st.nextToken()) + 1;
		K = Integer.parseInt(st.nextToken());
		
		map = new int[N][M];
		for(int i = 1; i < N; i++) {
			st = new StringTokenizer(br.readLine(), " ");
			for(int j = 1; j < M; j++)
				map[i][j] = Integer.parseInt(st.nextToken());
		}
		
		isSelected = new boolean[K]; // 순열 만들 때 체크할 용도
		numbers = new int[K]; // 각 줄의 인덱스를 담을 배열
		perms = new ArrayList<>(); // 인덱스 순열 담을 리스트
		int[][] operations = new int[K][3];
		for(int i = 0; i < K; i++) {
			st = new StringTokenizer(br.readLine(), " ");
			for(int j = 0; j < 3; j++)
				operations[i][j] = Integer.parseInt(st.nextToken());
		}
		perm(0);
		
//		for(int i = 0; i < K; i++) {
//			
//			int r = Integer.parseInt(st.nextToken());
//			int c = Integer.parseInt(st.nextToken());
//			int s = Integer.parseInt(st.nextToken());
//			rec = (2 * s + 1) / 2;
//			rotate(r - s, c - s, r + s, c + s, 0);
//		}

		int tmp;						// 행 더한 값
		int min = Integer.MAX_VALUE;	// 최종 출력값
		for(int i = 1; i < N; i++) {
			tmp = 0;
			for(int j = 1; j < M; j++) {
				tmp += map[i][j];
			}
			if(tmp < min)
				min = tmp;
		}
		
		System.out.println(min);
	}

	private static void perm(int cnt) {
		if(cnt == K) {
			perms.add(numbers);
			int[] pp = perms.get(0);
			System.out.println(Arrays.toString(pp));
			return;
			
		}
		
		for(int i = 0; i < K; i++) {
			if(isSelected[i]) continue;
			numbers[cnt] = i;
			isSelected[i] = true;
			perm(cnt + 1);
			isSelected[i] = false;
		}
		
	}

	private static void rotate(int startR, int startC, int endR, int endC, int cnt) {		
		if(cnt == rec)
			return;
		
		// 배열 정보 스택에 담기
		for(int i = startC; i < endC; i++)
			stack.push(map[startR][i]);
		for(int i = startR; i < endR; i++)
			stack.push(map[i][endC]);
		for(int i = endC; i > startC; i--)
			stack.push(map[endR][i]);
		for(int i = endR; i > startR; i--)
			stack.push(map[i][startC]);
		
		// 스택에서 배열로 담기
		for(int i = startR; i < endR; i++)
			map[i][startC] = stack.pop();
		for(int i = startC; i < endC; i++)
			map[endR][i] = stack.pop();
		for(int i = endR; i > startR; i--)
			map[i][endC] = stack.pop();		
		for(int i = endC; i > startC; i--)
			map[startR][i] = stack.pop();
		
		rotate(startR + 1, startC + 1, endR - 1, endC - 1, cnt + 1);
	}
	
}
